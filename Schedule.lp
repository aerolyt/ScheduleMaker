% _main conditional that will execute to generate a clean looking schedule
_main(List):-
	_buildSchedule(List, Schedule),
	schedule(Schedule).
	
schedule(Schedule).
	
% buildSchedule conditional:
% 1.) A single class always fits into a schedule
% 2.) Other classes must fit into the schedule generated by recursive calls
_buildSchedule([Class|Tail], [Sec]):-
	_class(Class, Sec, _, _, _),
	Tail = [].
_buildSchedule([Class|Tail], [Sec|Schedule]):-
	_class(Class, Sec, _, _, _),
	_buildSchedule(Tail,Schedule),
	_fitsSchedule(Sec, Schedule).

% fitsSchedule conditional:
% 1.) A single section will always fit into a schedule
% 2.) A class fits into a schedule if it doesn't share any days with the first class in the schedule, and fits with all the other classes
% 3.) A class that shares any one day with a class must have a time that does not conflict, and fit with all the other classes
_fitsSchedule(Sec, []).
_fitsSchedule(Sec, [HeadSec|Tail]):-
	_class(_, Sec, Days, _, _),
	_class(_, HeadSec, HeadDays, _, _),
	Sec \= HeadSec,
	not _daysEqual(Days, HeadDays),
	_fitsSchedule(Sec, Tail).
_fitsSchedule(Sec, [HeadSec|Tail]):-
	_class(_, Sec, Days, Start, End),
	_class(_, HeadSec, HeadDays, HeadStart, HeadEnd),
	Sec \= HeadSec,
	_daysEqual(Days, HeadDays),
	_timesDiff(Start, End, HeadStart, HeadEnd),
	_fitsSchedule(Sec, Tail).
	
% daysEqual conditional:
% 1.) If we reach a point where we have an empty list, we are done evaluating and the days a clearly not equal
% 2.) If the top two days are equal, we are done evaluating and return true
% 3.) Otherwise, we must choose to either hold one of the top variables to compare against the other tail, or to discard both and evaluate the next set of days
_daysEqual([],[]):- _fail.
_daysEqual(_,[]):- _fail.
_daysEqual([],_):- _fail.
_daysEqual([DayOne|_],[DayTwo|_]):-
	DayOne = DayTwo.
_daysEqual([DayOne|_],[DayTwo|TailTwo]):-
	DayOne \= DayTwo,
	_daysEqual(DayOne, TailTwo).
_daysEqual([DayOne|TailOne],[dayTwo|_]):-
	DayOne \= DayTwo,
	_daysEqual(TailOne, DayTwo).
_daysEqual([DayOne|TailOne],[DayTwo|TailTwo]):-
	DayOne \= DayTwo,
	_daysEqual(TailOne, TailTwo).

% timeDiff conditional
% The end time must either be before the start time, or the start time must come before the end time
_timesDiff(StartOne, _, _, EndTwo):-
	StartOne > EndTwo.
_timesDiff(_, EndOne, StartTwo, _):-
	EndOne < StartTwo.